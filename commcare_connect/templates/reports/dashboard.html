{% extends "base.html" %}
{% load static %}
{% load crispy_forms_tags %}
{% load django_tables2 %}
{% block title %}Admin Dashboard{% endblock %}
{% block content %}
<h2 class="my-2">Program Dashboard</h2>
<div class="container" x-data="dashboardStats()">
  <div class="mb-4">
    <div class="row mb-4" x-ref="filterForm" id="filterForm">
      {% crispy filter.form %}
    </div>
  </div>
  <div class="row">
    <div class="col-12 col-sm-6 col-md-3 mb-3">
      <div class="card">
        <div class="card-body">
          <div class="fw-bold">
            <span x-show="!isLoading" x-text="stats.active_users || 0" class="display-4">0</span>
            <span x-show="isLoading">
              <span class="spinner-border text-secondary opacity-50" role="status"></span>
              <span class="display-4">&nbsp;</span>
            </span>
          </div>
          <div class="small text-muted mt-1">Active FLWs</div>
        </div>
      </div>
    </div>
    <div class="col-12 col-sm-6 col-md-3 mb-3">
      <div class="card">
        <div class="card-body">
          <div class="fw-bold">
            <span x-show="!isLoading" x-text="stats.total_visits || 0" class="display-4">0</span>
            <span x-show="isLoading">
              <span class="spinner-border text-secondary opacity-50" role="status"></span>
              <span class="display-4">&nbsp;</span>
            </span>
          </div>
          <div class="small text-muted mt-1">Total Visits</div>
        </div>
      </div>
    </div>
    <div class="col-12 col-sm-6 col-md-3 mb-3">
      <div class="card">
        <div class="card-body">
          <div class="fw-bold">
            <span x-show="!isLoading" x-text="stats.verified_visits || 0" class="display-4">0</span>
            <span x-show="isLoading">
              <span class="spinner-border text-secondary opacity-50" role="status"></span>
              <span class="display-4">&nbsp;</span>
            </span>
          </div>
          <div class="small text-muted mt-1">Verified Visits</div>
        </div>
      </div>
    </div>
    <div class="col-12 col-sm-6 col-md-3 mb-3">
      <div class="card">
        <div class="card-body">
          <div class="fw-bold">
            <span x-show="!isLoading" x-text="stats.percent_verified || '0.0%'" class="display-4">0</span>
            <span x-show="isLoading">
              <span class="spinner-border text-secondary opacity-50" role="status"></span>
              <span class="display-4">&nbsp;</span>
            </span>
          </div>
          <div class="small text-muted mt-1">Percent Verified</div>
        </div>
      </div>
    </div>
  </div>
</div>
<div class="row">
  <div class="col-12">
    <h3 class="my-2">Service Delivery Map</h3>
    <div class="position-relative">
      <div id="map" class="mt-3 mb-2 rounded border" style="height: 900px;"></div>
      <div id="map-loading" class="position-absolute top-0 start-0 w-100 h-100 bg-dark bg-opacity-50 d-flex justify-content-center align-items-center">
        <div class="spinner-border text-light" role="status">
          <span class="visually-hidden">Loading map...</span>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock content %}
{% block inline_javascript %}
{{ block.super }}
<script>
  function dashboardStats() {
    return {
      stats: {
        total_visits: 0,
        active_users: 0,
        verified_visits: 0,
        percent_verified: "0.0%"
      },
      isLoading: false,
      async init() {
        await this.loadStats();
        const formElement = this.$refs.filterForm.querySelector('form');
        formElement.querySelectorAll('select, input').forEach(input => {
          if (input.value) {
            input.dispatchEvent(new Event('change'));
          }
          input.addEventListener('change', () => {
            this.loadStats();
            window.refreshMapData();
          });
        });
      },
      async loadStats(event) {
        try {
          this.isLoading = true;
          const formElement = this.$refs.filterForm.querySelector('form');
          const formData = new FormData(formElement);
          const queryString = new URLSearchParams(formData).toString();
          const url = `{% url 'reports:dashboard_stats_api' %}?${queryString}`;
          const response = await fetch(url);
          if (!response.ok) throw new Error('Failed to load stats');
          const data = await response.json();
          this.stats = data;
        } catch (error) {
          console.error('Error loading dashboard stats:', error);
        } finally {
          this.isLoading = false;
        }
      }
    }
  }
</script>
<script type="module">
  let map;
  const mapLoading = document.getElementById('map-loading');

  // Add this function to handle map data refresh
  window.refreshMapData = () => {
    if (!map) return;
    mapLoading.classList.remove('d-none');  // Show loading state

    const formElement = document.querySelector('#filterForm form');
    const formData = new FormData(formElement);
    const queryString = new URLSearchParams(formData).toString();

    // Update the source data with new filters
    map.getSource('visits').setData(
      `{% url "reports:visit_map_data" %}?${queryString}`,
      // Hide loading state after data is loaded
      () => mapLoading.classList.add('d-none')
    );
  };

  window.addEventListener('DOMContentLoaded', () => {
    mapboxgl.accessToken = "{{ mapbox_token }}";
    const cluster = {% if cluster_visits %}true{% else %}false{% endif %};
  map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/dark-v11',
    center: [20, 0], // Centered on Africa (roughly central coordinates)
    zoom: 3,
  });

  // filters for classifying visits by status
  const approved = ['==', ['get', 'status'], 'approved'];
  const pending = ['all',
    ['!=', ['get', 'status'], 'approved'],
    ['!=', ['get', 'status'], 'rejected']
  ];
  const rejected = ['==', ['get', 'status'], 'rejected'];

  // colors to use for the categories
  const colors = ['#00FF00', '#FFFF00', '#FF0000'];

  map.on('load', () => {
    // Modify the source configuration to include initial filters
    const formElement = document.querySelector('#filterForm form');
    const formData = new FormData(formElement);
    const queryString = new URLSearchParams(formData).toString();

    map.addSource('visits', {
      type: 'geojson',
      data: `{% url "reports:visit_map_data" %}?${queryString}`,
      cluster: cluster,
      clusterMaxZoom: 12,
      clusterRadius: 80,
      clusterProperties: {
        // keep separate counts for each status category in a cluster
        'approved': ['+', ['case', approved, 1, 0]],
        'pending': ['+', ['case', pending, 1, 0]],
        'rejected': ['+', ['case', rejected, 1, 0]]
      }
    });

    map.addLayer({
      id: 'unclustered-point',
      type: 'circle',
      source: 'visits',
      filter: ['!', ['has', 'point_count']],
      paint: {
        'circle-color': ['get', 'color'],
        'circle-radius': 4,
        'circle-stroke-width': 1,
        'circle-stroke-color': '#fff'
      }
    });

    // When a click event occurs on a feature in
    // the unclustered-point layer, open a popup at
    // the location of the feature, with
    // description HTML from its properties.
    map.on('click', 'unclustered-point', (e) => {
      const coordinates = e.features[0].geometry.coordinates.slice();
      const status = e.features[0].properties.status;
      const rawDate = e.features[0].properties.visit_date;
      const visitDate = new Date(rawDate).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });


      // Ensure that if the map is zoomed out such that
      // multiple copies of the feature are visible, the
      // popup appears over the copy being pointed to.
      if (['mercator', 'equirectangular'].includes(map.getProjection().name)) {
        while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {
          coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;
        }
      }

      new mapboxgl.Popup()
        .setLngLat(coordinates)
        .setHTML(
          `Visit Date: ${visitDate}<br>Status: ${status}`
        )
        .addTo(map);
    });

    // after the GeoJSON data is loaded, update markers on the screen on every frame
    // objects for caching and keeping track of HTML marker objects (for performance)
    const markers = {};
    let markersOnScreen = {};
    function updateMarkers() {
      const newMarkers = {};
      const features = map.querySourceFeatures('visits');

      // for every cluster on the screen, create an HTML marker for it (if we didn't yet),
      // and add it to the map if it's not there already
      for (const feature of features) {
        const coords = feature.geometry.coordinates;
        const props = feature.properties;
        if (!props.cluster) continue;
        const id = props.cluster_id;

        let marker = markers[id];
        if (!marker) {
          const el = createDonutChart({
            ...props,
            cluster_id: id,  // Make sure cluster_id is passed
            coordinates: coords  // Pass the coordinates
          });
          marker = markers[id] = new mapboxgl.Marker({
            element: el
          }).setLngLat(coords);
        }
        newMarkers[id] = marker;

        if (!markersOnScreen[id]) marker.addTo(map);
      }
      // for every marker we've added previously, remove those that are no longer visible
      for (const id in markersOnScreen) {
        if (!newMarkers[id]) markersOnScreen[id].remove();
      }
      markersOnScreen = newMarkers;
    }

    map.on('render', () => {
      if (!map.isSourceLoaded('visits')) return;
      updateMarkers();
    });

    // Hide loading overlay when initial map load is complete
    mapLoading.classList.add('d-none');
  });

  // Show loading state if map errors
  map.on('error', () => {
    mapLoading.classList.add('d-none');
    // Optionally add error messaging here
  });

  // code for creating an SVG donut chart from feature properties
  function createDonutChart(props) {
    const offsets = [];
    const counts = [
      props.approved,
      props.pending,
      props.rejected
    ];
    let total = 0;
    for (const count of counts) {
      offsets.push(total);
      total += count;
    }
    const fontSize =
      total >= 1000 ? 22 : total >= 100 ? 20 : total >= 10 ? 18 : 16;
    const r =
      total >= 1000 ? 50 : total >= 100 ? 32 : total >= 10 ? 24 : 18;
    const r0 = Math.round(r * 0.8);
    const w = r * 2;

    let html = `<div>
            <svg width="${w}" height="${w}" viewbox="0 0 ${w} ${w}" text-anchor="middle" style="font: ${fontSize}px sans-serif; display: block">`;

    for (let i = 0; i < counts.length; i++) {
      html += donutSegment(
        offsets[i] / total,
        (offsets[i] + counts[i]) / total,
        r,
        r0,
        colors[i]
      );
    }
    html += `<circle cx="${r}" cy="${r}" r="${r0}" fill="transparent" />
            <text dominant-baseline="central" transform="translate(${r}, ${r})" fill="white">
                ${total.toLocaleString()}
            </text>
            </svg>
            </div>`;

    const el = document.createElement('div');
    el.innerHTML = html;
    el.style.cursor = 'pointer';

    // Click handler to zoom and navigate to the cluster
    el.addEventListener('click', (e) => {
      map.getSource('visits').getClusterExpansionZoom(
        props.cluster_id,
        (err, zoom) => {
          if (err) return;

          map.easeTo({
            center: props.coordinates,
            zoom: zoom
          });
        }
      );
    });

    return el;
  }

  function donutSegment(start, end, r, r0, color) {
    if (end - start === 1) end -= 0.00001;
    const a0 = 2 * Math.PI * (start - 0.25);
    const a1 = 2 * Math.PI * (end - 0.25);
    const x0 = Math.cos(a0),
      y0 = Math.sin(a0);
    const x1 = Math.cos(a1),
      y1 = Math.sin(a1);
    const largeArc = end - start > 0.5 ? 1 : 0;

    // draw an SVG path
    return `<path d="M ${r + r0 * x0} ${r + r0 * y0} L ${r + r * x0} ${r + r * y0
      } A ${r} ${r} 0 ${largeArc} 1 ${r + r * x1} ${r + r * y1} L ${r + r0 * x1
      } ${r + r0 * y1} A ${r0} ${r0} 0 ${largeArc} 0 ${r + r0 * x0} ${r + r0 * y0
      }" fill="${color}" />`;
  }
  });

</script>
{% endblock %}
